/**
 * TypeScript type definition generator
 * Generates .d.ts files with type-safe environment variables
 */

import type { EnvVariable, TypeInfo, GeneratorOptions } from '../types/index.js';
import { GenerationError } from '../utils/errors.js';
import { EnvParser } from '../parsers/env-parser.js';

export class TypeGenerator {
  private readonly parser: EnvParser;

  constructor() {
    this.parser = new EnvParser();
  }

  /**
   * Generate TypeScript type definitions
   */
  public generateTypes(variables: EnvVariable[], options: GeneratorOptions): string {
    try {
      const typeInfos = this.buildTypeInfos(variables, options);
      return this.buildTypeDefinition(typeInfos);
    } catch (error) {
      throw new GenerationError((error as Error).message);
    }
  }

  /**
   * Build type information for each variable
   */
  private buildTypeInfos(variables: EnvVariable[], options: GeneratorOptions): TypeInfo[] {
    return variables.map((variable) => {
      const constraint = options.schema?.[variable.key];
      const isRequired = constraint?.required ?? options.requiredVars.includes(variable.key);
      const comment = constraint?.description ?? variable.comment;

      let type = 'string';

      if (constraint?.enum?.length) {
        type = constraint.enum.map((value) => `'${value}'`).join(' | ');
      } else if (constraint?.union?.length) {
        type = constraint.union.map((value) => this.normalizeType(value)).join(' | ');
      } else if (constraint?.type) {
        type = this.normalizeType(constraint.type);
      } else if (options.parseTypes) {
        const inferredType = this.parser.inferType(variable.value);
        type = inferredType;
      }

      return {
        name: variable.key,
        type,
        required: isRequired || options.strict,
        parsed: options.parseTypes,
        comment,
      };
    });
  }

  private normalizeType(type: string): string {
    if (type === 'object') {
      return 'Record<string, unknown>';
    }
    return type;
  }

  /**
   * Build TypeScript type definition string
   */
  private buildTypeDefinition(typeInfos: TypeInfo[]): string {
    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Do not edit manually');
    lines.push(' */');
    lines.push('');

    // Extend NodeJS.ProcessEnv
    lines.push('declare namespace NodeJS {');
    lines.push('  interface ProcessEnv {');

    for (const typeInfo of typeInfos) {
      // Add comment if exists
      if (typeInfo.comment) {
        lines.push(`    /** ${typeInfo.comment} */`);
      }

      // Add type definition
      const optional = typeInfo.required ? '' : '?';
      const baseType = typeInfo.type === 'string' ? 'string' : typeInfo.type;
      const undefinedType = typeInfo.required ? '' : ' | undefined';

      lines.push(`    ${typeInfo.name}${optional}: ${baseType}${undefinedType};`);
    }

    lines.push('  }');
    lines.push('}');
    lines.push('');

    // Export typed helper object
    lines.push('/**');
    lines.push(' * Typed environment variables with runtime parsing');
    lines.push(' */');
    lines.push('export declare const env: {');

    for (const typeInfo of typeInfos) {
      if (typeInfo.comment) {
        lines.push(`  /** ${typeInfo.comment} */`);
      }

      const optional = typeInfo.required ? '' : '?';
      lines.push(`  ${typeInfo.name}${optional}: ${typeInfo.type};`);
    }

    lines.push('};');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate runtime helper code
   */
  public generateRuntimeHelper(variables: EnvVariable[], options: GeneratorOptions): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Runtime environment variable helpers');
    lines.push(' */');
    lines.push('');

    lines.push('function parseValue(key: string, value: string | undefined): unknown {');
    lines.push('  if (value === undefined) return undefined;');
    lines.push('');
    lines.push('  // Try parsing as boolean');
    lines.push('  if (value.toLowerCase() === "true") return true;');
    lines.push('  if (value.toLowerCase() === "false") return false;');
    lines.push('');
    lines.push('  // Try parsing as number');
    lines.push('  const num = Number(value);');
    lines.push('  if (!isNaN(num) && /^-?\\d+(\\.\\d+)?$/.test(value)) return num;');
    lines.push('');
    lines.push('  // Try parsing as JSON');
    lines.push('  if ((value.startsWith("{") && value.endsWith("}")) ||');
    lines.push('      (value.startsWith("[") && value.endsWith("]"))) {');
    lines.push('    try {');
    lines.push('      return JSON.parse(value);');
    lines.push('    } catch {');
    lines.push('      // Fall through to return as string');
    lines.push('    }');
    lines.push('  }');
    lines.push('');
    lines.push('  return value;');
    lines.push('}');
    lines.push('');
    lines.push('function applyTransform(value: unknown, transformer?: string): unknown {');
    lines.push('  if (!transformer) return value;');
    lines.push('  if (typeof value !== "string") return value;');
    lines.push('');
    lines.push('  if (transformer === "json") {');
    lines.push('    try {');
    lines.push('      return JSON.parse(value);');
    lines.push('    } catch {');
    lines.push('      return value;');
    lines.push('    }');
    lines.push('  }');
    lines.push('');
    lines.push('  if (transformer === "base64") {');
    lines.push('    try {');
    lines.push('      return Buffer.from(value, "base64").toString("utf-8");');
    lines.push('    } catch {');
    lines.push('      return value;');
    lines.push('    }');
    lines.push('  }');
    lines.push('');
    lines.push('  if (transformer === "trim") {');
    lines.push('    return value.trim();');
    lines.push('  }');
    lines.push('');
    lines.push('  return value;');
    lines.push('}');
    lines.push('');

    // Build env object
    lines.push('export const env = {');

    const typeInfos = this.buildTypeInfos(variables, options);

    for (let i = 0; i < typeInfos.length; i++) {
      const typeInfo = typeInfos[i];
      const isLast = i === typeInfos.length - 1;
      const constraint = options.schema?.[typeInfo.name];
      const defaultValue = constraint?.defaultValue;

      if (options.parseTypes) {
        lines.push(`  get ${typeInfo.name}() {`);
        if (typeInfo.required && options.strict) {
          lines.push(`    const raw = process.env.${typeInfo.name};`);
          if (!defaultValue) {
            lines.push(`    if (raw === undefined) {`);
            lines.push(
              `      throw new Error('Required environment variable ${typeInfo.name} is not defined');`
            );
            lines.push(`    }`);
          }
          const resolved = defaultValue ? `raw ?? '${defaultValue}'` : 'raw';
          const parseCall = `parseValue('${typeInfo.name}', ${resolved}) as ${typeInfo.type}`;
          if (constraint?.transformer) {
            lines.push(
              `    return applyTransform(${parseCall} as unknown as string, '${constraint.transformer}') as ${typeInfo.type};`
            );
          } else {
            lines.push(`    return ${parseCall};`);
          }
        } else {
          const source = defaultValue
            ? `process.env.${typeInfo.name} ?? '${defaultValue}'`
            : `process.env.${typeInfo.name}`;
          const parseCall = `parseValue('${typeInfo.name}', ${source}) as ${typeInfo.type} | undefined`;
          if (constraint?.transformer) {
            lines.push(
              `    return applyTransform(${parseCall} as unknown as string, '${constraint.transformer}') as ${typeInfo.type} | undefined;`
            );
          } else {
            lines.push(`    return ${parseCall};`);
          }
        }

        lines.push(`  }${isLast ? '' : ','}`);
      } else {
        lines.push(`  get ${typeInfo.name}() {`);

        if (typeInfo.required && options.strict) {
          lines.push(`    const value = process.env.${typeInfo.name};`);
          lines.push(`    if (value === undefined) {`);
          lines.push(
            `      throw new Error('Required environment variable ${typeInfo.name} is not defined');`
          );
          lines.push(`    }`);
          lines.push(`    return value;`);
        } else {
          lines.push(`    return process.env.${typeInfo.name};`);
        }

        lines.push(`  }${isLast ? '' : ','}`);
      }
    }

    lines.push('};');
    lines.push('');

    return lines.join('\n');
  }
}
