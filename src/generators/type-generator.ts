/**
 * TypeScript type definition generator
 * Generates .d.ts files with type-safe environment variables
 */

import type { EnvVariable, TypeInfo, GeneratorOptions } from '../types/index.js';
import { camelCase, snakeCase } from '@kitiumai/utils-ts';
import { createGenerationError } from '../utils/errors.js';
import { EnvParser } from '../parsers/env-parser.js';

export class TypeGenerator {
  private readonly parser: EnvParser;

  constructor() {
    this.parser = new EnvParser();
  }

  /**
   * Generate TypeScript type definitions
   */
  public generateTypes(variables: EnvVariable[], options: GeneratorOptions): string {
    try {
      const typeInfos = this.buildTypeInfos(variables, options);
      return this.buildTypeDefinition(typeInfos);
    } catch (error) {
      throw createGenerationError((error as Error).message, {
        variableCount: variables.length,
        parseTypes: options.parseTypes,
      });
    }
  }

  /**
   * Build type information for each variable
   */
  private buildTypeInfos(variables: EnvVariable[], options: GeneratorOptions): TypeInfo[] {
    return variables.map((variable) => {
      const isRequired = options.requiredVars.includes(variable.key);
      let type = 'string';

      if (options.parseTypes) {
        const inferredType = this.parser.inferType(variable.value);
        type = inferredType;
      }

      return {
        name: variable.key,
        type,
        required: isRequired || options.strict,
        parsed: options.parseTypes,
        comment: variable.comment,
        camelCaseName: camelCase(variable.key),
        snakeCaseName: snakeCase(variable.key),
      };
    });
  }

  /**
   * Build TypeScript type definition string
   */
  private buildTypeDefinition(typeInfos: TypeInfo[]): string {
    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Do not edit manually');
    lines.push(' */');
    lines.push('');

    // Extend NodeJS.ProcessEnv
    lines.push('declare namespace NodeJS {');
    lines.push('  interface ProcessEnv {');

    for (const typeInfo of typeInfos) {
      // Add comment if exists
      const comments: string[] = [];
      if (typeInfo.comment) {
        comments.push(typeInfo.comment);
      }
      // Add case convention info
      if (typeInfo.camelCaseName && typeInfo.camelCaseName !== typeInfo.name.toLowerCase()) {
        comments.push(`camelCase: ${typeInfo.camelCaseName}, snakeCase: ${typeInfo.snakeCaseName}`);
      }

      if (comments.length > 0) {
        lines.push(`    /** ${comments.join(' | ')} */`);
      }

      // Add type definition
      const optional = typeInfo.required ? '' : '?';
      const baseType = typeInfo.type === 'string' ? 'string' : typeInfo.type;
      const undefinedType = typeInfo.required ? '' : ' | undefined';

      lines.push(`    ${typeInfo.name}${optional}: ${baseType}${undefinedType};`);
    }

    lines.push('  }');
    lines.push('}');
    lines.push('');

    // Export typed helper object
    lines.push('/**');
    lines.push(' * Typed environment variables with runtime parsing');
    lines.push(' */');
    lines.push('export declare const env: {');

    for (const typeInfo of typeInfos) {
      if (typeInfo.comment) {
        lines.push(`  /** ${typeInfo.comment} */`);
      }

      const optional = typeInfo.required ? '' : '?';
      lines.push(`  ${typeInfo.name}${optional}: ${typeInfo.type};`);
    }

    lines.push('};');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate runtime helper code
   */
  public generateRuntimeHelper(variables: EnvVariable[], options: GeneratorOptions): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Runtime environment variable helpers');
    lines.push(' */');
    lines.push('');

    lines.push('function parseValue(key: string, value: string | undefined): unknown {');
    lines.push('  if (value === undefined) return undefined;');
    lines.push('');
    lines.push('  // Try parsing as boolean');
    lines.push('  if (value.toLowerCase() === "true") return true;');
    lines.push('  if (value.toLowerCase() === "false") return false;');
    lines.push('');
    lines.push('  // Try parsing as number');
    lines.push('  const num = Number(value);');
    lines.push('  if (!isNaN(num) && /^-?\\d+(\\.\\d+)?$/.test(value)) return num;');
    lines.push('');
    lines.push('  // Try parsing as JSON');
    lines.push('  if ((value.startsWith("{") && value.endsWith("}")) ||');
    lines.push('      (value.startsWith("[") && value.endsWith("]"))) {');
    lines.push('    try {');
    lines.push('      return JSON.parse(value);');
    lines.push('    } catch {');
    lines.push('      // Fall through to return as string');
    lines.push('    }');
    lines.push('  }');
    lines.push('');
    lines.push('  return value;');
    lines.push('}');
    lines.push('');

    // Build env object
    lines.push('export const env = {');

    const typeInfos = this.buildTypeInfos(variables, options);

    for (let i = 0; i < typeInfos.length; i++) {
      const typeInfo = typeInfos[i];
      const isLast = i === typeInfos.length - 1;

      if (options.parseTypes) {
        lines.push(`  get ${typeInfo.name}() {`);

        if (typeInfo.required && options.strict) {
          lines.push(`    const value = process.env.${typeInfo.name};`);
          lines.push(`    if (value === undefined) {`);
          lines.push(
            `      throw new Error('Required environment variable ${typeInfo.name} is not defined');`
          );
          lines.push(`    }`);
          lines.push(`    return parseValue('${typeInfo.name}', value) as ${typeInfo.type};`);
        } else {
          lines.push(
            `    return parseValue('${typeInfo.name}', process.env.${typeInfo.name}) as ${typeInfo.type} | undefined;`
          );
        }

        lines.push(`  }${isLast ? '' : ','}`);
      } else {
        lines.push(`  get ${typeInfo.name}() {`);

        if (typeInfo.required && options.strict) {
          lines.push(`    const value = process.env.${typeInfo.name};`);
          lines.push(`    if (value === undefined) {`);
          lines.push(
            `      throw new Error('Required environment variable ${typeInfo.name} is not defined');`
          );
          lines.push(`    }`);
          lines.push(`    return value;`);
        } else {
          lines.push(`    return process.env.${typeInfo.name};`);
        }

        lines.push(`  }${isLast ? '' : ','}`);
      }
    }

    lines.push('};');
    lines.push('');

    return lines.join('\n');
  }
}
